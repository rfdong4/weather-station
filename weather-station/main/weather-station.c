/* HTTP GET Example using plain POSIX sockets

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "protocol_examples_common.h"
#include "cJSON.h"

#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include "lwip/netdb.h"
#include "lwip/dns.h"
#include "sdkconfig.h"
#include "driver/i2c_master.h"

#include "mqtt_client.h"
#include <math.h>
/* Constants that aren't configurable in menuconfig */
#define WEB_SERVER "10.0.0.195"
#define WEB_PORT "8000"
#define WEB_PATH "/"

#define I2C_MASTER_SCL_IO           8       /*!< GPIO number used for I2C master clock */
#define I2C_MASTER_SDA_IO           10      /*!< GPIO number used for I2C master data  */
#define I2C_MASTER_NUM              I2C_NUM_0                   /*!< I2C port number for master dev */
#define I2C_MASTER_FREQ_HZ          400000 /*!< I2C master clock frequency */
#define I2C_MASTER_TX_BUF_DISABLE   0                           /*!< I2C master doesn't need buffer */
#define I2C_MASTER_RX_BUF_DISABLE   0                           /*!< I2C master doesn't need buffer */
#define I2C_MASTER_TIMEOUT_MS       1000

#define SHTC3_ADDR         0x70        /*!< Address of the SHTC3 */
#define MPU9250_WHO_AM_I_REG_ADDR   0x75        /*!< Register addresses of the "who am I" register */
#define MPU9250_PWR_MGMT_1_REG_ADDR 0x6B        /*!< Register addresses of the power management register */
#define MPU9250_RESET_BIT           7

#define TRIG_GPIO  GPIO_NUM_2
#define ECHO_GPIO  GPIO_NUM_3

#define MAX_TIMEOUT_US 100000
#define PAYLOAD_MAX_LEN 128

#define AWS_IOT_ENDPOINT    "a165yetla5y0cr-ats.iot.us-east-2.amazonaws.com"
#define AWS_IOT_TOPIC       "device/esp32_weather_station/data"
#define AWS_IOT_CLIENT_ID   "esp32_weather_station"

static const char *TAG = "AWS_WEATHER";

// --- Embedded Certificate Data ---
// These symbols are generated by the build system from the .crt and .key files
extern const uint8_t client_crt_start[] asm("_binary_client_crt_start");
extern const uint8_t client_crt_end[]   asm("_binary_client_crt_end");
extern const uint8_t client_key_start[] asm("_binary_client_key_start");
extern const uint8_t client_key_end[]   asm("_binary_client_key_end");
extern const uint8_t server_crt_start[] asm("_binary_server_crt_start");
extern const uint8_t server_crt_end[]   asm("_binary_server_crt_end");

esp_mqtt_client_handle_t client;

// Event handlers
static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        ESP_LOGI(TAG, "Disconnected from Wi-Fi, retrying...");
        esp_wifi_connect();
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "Got IP: " IPSTR, IP2STR(&event->ip_info.ip));
        // Start MQTT client after getting an IP
        esp_mqtt_client_start(client);
    }
}

static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) {
    ESP_LOGD(TAG, "Event dispatched from event loop base=%s, event_id=%ld", base, event_id);
    esp_mqtt_event_handle_t event = event_data;
    switch ((esp_mqtt_event_id_t)event_id) {
    case MQTT_EVENT_CONNECTED:
        ESP_LOGI(TAG, "MQTT_EVENT_CONNECTED");
        break;
    case MQTT_EVENT_DISCONNECTED:
        ESP_LOGI(TAG, "MQTT_EVENT_DISCONNECTED");
        break;
    case MQTT_EVENT_ERROR:
        ESP_LOGI(TAG, "MQTT_EVENT_ERROR");
        if (event->error_handle->error_type == MQTT_ERROR_TYPE_TCP_TRANSPORT) {
            ESP_LOGI(TAG, "Last error code reported from esp-tls: 0x%x", event->error_handle->esp_tls_last_esp_err);
            ESP_LOGI(TAG, "Last error code reported from tls stack: 0x%x", event->error_handle->esp_tls_stack_err);
        }
        break;
    default:
        ESP_LOGI(TAG, "Other event id:%d", event_id);
        break;
    }
}




// static const char *PAYLOAD = "{\"humidity\":,\"temperature\":}";
char payload[PAYLOAD_MAX_LEN];

void shtc3_read_data(i2c_master_dev_handle_t dev_handle, uint16_t * temperature, uint16_t * humidity) {
    uint8_t data[6] = { 0 };

    esp_err_t err = i2c_master_receive(
        dev_handle,
        data,
        sizeof(data),
        I2C_MASTER_TIMEOUT_MS / portTICK_PERIOD_MS
    );

     // Combine bytes to form the raw values (ignore the CRC bytes)
     uint16_t raw_temperature  = ((uint16_t)data[0] << 8) | data[1];
     uint16_t raw_humidity = ((uint16_t)data[3] << 8) | data[4];
 
     *humidity = raw_humidity;
     *temperature = raw_temperature;
}

esp_err_t shtc3_send_command(uint16_t cmd, i2c_master_dev_handle_t dev_handle) {
    uint8_t data[2] = { (uint8_t)((cmd&0xff00)>>8), (uint8_t)(cmd&0xff) };
    return i2c_master_transmit(
        dev_handle,
        data,
        sizeof(data),
        I2C_MASTER_TIMEOUT_MS / portTICK_PERIOD_MS
    );

}



/**
 * @brief i2c master initialization
 */
static void i2c_master_init(i2c_master_bus_handle_t *bus_handle, i2c_master_dev_handle_t *dev_handle)
{
    i2c_master_bus_config_t bus_config = {
        .i2c_port = I2C_MASTER_NUM,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .flags.enable_internal_pullup = true,
    };
    ESP_ERROR_CHECK(i2c_new_master_bus(&bus_config, bus_handle));

    i2c_device_config_t dev_config = {
        .dev_addr_length = I2C_ADDR_BIT_LEN_7,
        .device_address = SHTC3_ADDR,
        .scl_speed_hz = I2C_MASTER_FREQ_HZ,
    };
    ESP_ERROR_CHECK(i2c_master_bus_add_device(*bus_handle, &dev_config, dev_handle));

    
}


float read_temp(i2c_master_dev_handle_t dev_handle) {
    ESP_ERROR_CHECK(shtc3_send_command(0x3517, dev_handle));
        vTaskDelay(pdMS_TO_TICKS(12)); // Give a small delay after wakeup

        
        ESP_ERROR_CHECK(shtc3_send_command(0x7CA2, dev_handle));
        
        vTaskDelay(pdMS_TO_TICKS(12));

        
        uint16_t raw_temperature = 0, raw_humidity = 0;
        shtc3_read_data(dev_handle, &raw_temperature, &raw_humidity);

        
        float temperature = -45.0f + 175.0f * (raw_temperature / 65536.0f);
        // float humidity    = 100.0f * (raw_humidity / 65536.0f);
        // float temperatureF = (temperature * 1.8) + 32;

        
        // 5. Put the sensor to sleep to conserve power
        ESP_ERROR_CHECK(shtc3_send_command(0xB098, dev_handle));
        vTaskDelay(pdMS_TO_TICKS(15));
        return temperature;
}

float read_hum(i2c_master_dev_handle_t dev_handle) {
    ESP_ERROR_CHECK(shtc3_send_command(0x3517, dev_handle));
        vTaskDelay(pdMS_TO_TICKS(12)); // Give a small delay after wakeup

        
        ESP_ERROR_CHECK(shtc3_send_command(0x7CA2, dev_handle));
        
        vTaskDelay(pdMS_TO_TICKS(12));

        
        uint16_t raw_temperature = 0, raw_humidity = 0;
        shtc3_read_data(dev_handle, &raw_temperature, &raw_humidity);

        
        // float temperature = -45.0f + 175.0f * (raw_temperature / 65536.0f);
        float humidity    = 100.0f * (raw_humidity / 65536.0f);
        // float temperatureF = (temperature * 1.8) + 32;

        
        // 5. Put the sensor to sleep to conserve power
        ESP_ERROR_CHECK(shtc3_send_command(0xB098, dev_handle));
        vTaskDelay(pdMS_TO_TICKS(15));
        return humidity;
}

void make_payload(i2c_master_dev_handle_t dev) {
    
    float h = read_hum(dev);
    float t = read_temp(dev);

    // Format as JSON: {"humidity":42.50,"temperature":23.10}
    int len = snprintf(payload, PAYLOAD_MAX_LEN,
                       "{\"humidity\":%.2f,\"temperature\":%.2f}",
                       h, t);

    if (len < 0 || len >= PAYLOAD_MAX_LEN) {
        // handle error: truncated or encoding failure
        return;
    }

    
}

void publisher_task(void *pvParameters) {
    i2c_master_bus_handle_t bus_handle;
    i2c_master_dev_handle_t dev_handle;
    
    i2c_master_init(&bus_handle, &dev_handle);
    while (1) {
        float h = read_hum(dev_handle);
        float t = read_temp(dev_handle);
        

        cJSON *root = cJSON_CreateObject();
        cJSON_AddNumberToObject(root, "temperature", round(t));
        cJSON_AddNumberToObject(root, "humidity", round(h));
        cJSON_AddStringToObject(root, "deviceID", AWS_IOT_CLIENT_ID);

        char *json_payload = cJSON_PrintUnformatted(root);

        // Publish data
        int msg_id = esp_mqtt_client_publish(client, AWS_IOT_TOPIC, json_payload, 0, 1, 0);
        if (msg_id != -1) {
            ESP_LOGI(TAG, "Sent publish successful, msg_id=%d, payload: %s", msg_id, json_payload);
        } else {
            ESP_LOGE(TAG, "Failed to publish message");
        }
        
        cJSON_Delete(root);
        free(json_payload);
        
        vTaskDelay(pdMS_TO_TICKS(15000)); // Publish every 30 seconds
    }
}

void wifi_init_sta(void) {
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_sta();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    esp_event_handler_instance_t instance_any_id;
    esp_event_handler_instance_t instance_got_ip;
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL, &instance_any_id));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL, &instance_got_ip));

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = CONFIG_EXAMPLE_WIFI_SSID,
            .password = CONFIG_EXAMPLE_WIFI_PASSWORD,
        },
    };
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());

    ESP_LOGI(TAG, "wifi_init_sta finished.");
}

void mqtt_app_start(void) {
    const esp_mqtt_client_config_t mqtt_cfg = {
        .broker = {
            .address.uri = "mqtts://" AWS_IOT_ENDPOINT ":8883",
            .verification.certificate = (const char *)server_crt_start
        },
        .credentials = {
            .client_id = AWS_IOT_CLIENT_ID,
            .authentication = {
                .certificate = (const char *)client_crt_start,
                .key = (const char *)client_key_start,
            },
        }
    };

    client = esp_mqtt_client_init(&mqtt_cfg);
    esp_mqtt_client_register_event(client, ESP_EVENT_ANY_ID, mqtt_event_handler, NULL);
}


void app_main(void)
{
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    ESP_LOGI(TAG, "ESP-IDF AWS Weather Station");

    // Start services
    mqtt_app_start();
    wifi_init_sta();

    // Create the publisher task
    xTaskCreate(&publisher_task, "publisher_task", 4096, NULL, 5, NULL);

    
    
}
